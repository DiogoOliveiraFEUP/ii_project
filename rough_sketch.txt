requisito 1{
    -bloco de tapetes lineares
    -bloco tapetes rot
    -bloco maquina
    -bloco master
    -série de caminhos entre armazem e maquinas/tapetes
    -gestor de armazem
}

{

Transformação de P2 -> P7
    MES -> PLC
    P2 -> P7 = P2->P3 + P3->P4 + P4->P5 + P5->P6 + P6->P7
    A -> P2->P3
    A -> P3->P4
    B->P4 ->P5
    C
    D



    transformação
    {
        movements{
            armazem:a, Aa1=1
            a:a,
            a:b,
            b:c,
            c:d,
            d:armazem;
        }
    }


}



### "Pedido"  = O que recebe por UDP/IP - XML
            . Transformação de Peças
            . Descarga de Peças
            . Existências de Peças
            . Lista de Ordens

### "Ordem"  = pedido a efetuar na fábrica/PLC
            . Transformação de Peças
            . Descarga de Peças

//Na realidade, uma ordem tem "n" ordens iguais a executar sequencialmente.

### "Transformação" = parte da ordem de transformação de peças
    
    "Ordem" P1 [->] P5 = "Transformações" P1->P2 + P2->P3 + P3->P4 + P4->P5



requisito_2(){
    
    // Threads:

    - Listener(){
        . Espera até receber novo pacote UDP/IP
        . Quando recebe chama parser
            
            - Parser()
                . Deteta tipo de pedido
                . Desconstroi pedido
                . Trata do pedido
                    * Tranformação de Peças -> Inserir na DB
                    * Descarga de Peças -> Inserir na DB
                    * Existência de Peças -> Executar Pedido
                        . Ir buscar à DB
                        . Enviar resposta UDP/IP
                    * Lista de Ordens -> Executar Pedido
                        . Ir buscar à DB
                        . Enviar resposta UDP/IP
    }

    // As ordens são agendadas logo quando são inseridas na DB ou existe
    // uma thread "Scheduler" sempre a correr que vê as ordens não agendadas
    // e agenda-as (e se necessário altera schedule das outras)?
    
    // Nota: Na lista de ordens temos de dizer qual a previsão de inicio e fim
    // das ordens. Será possível haver um pedido de lista de ordens antes do
    // scheduler agendar a tarefa? Será problemático?


    
    // Separar em ordens agendadas e não agendadas?


    - Scheduler( List<Transformações> , List<Orders_atuais> ){    

        . Calcula Ocupação das Máquinas para cada uma das transformações //????
        
        . Organizar temporalmente a ordem das peças //???

        . return List<Orders>

    }

    - Order_Manager(){
        . Vê se uma ordem está pronta
        . Manda executar ordens
    }

    - Order_Executer(){
        . Gere Tapetes, Máquinas e Armazém necessários para executar a ordem
        
        . Handler para OPC-UA?

    }

    - Interface_Grafica(){
        // Interface gráfica tipo Scada, JavaSwing?

        . Estatisticas
        . Estado da fábrica
        . Ordens em espera
        . Ações? (emergência, ... )?
    }
    
}